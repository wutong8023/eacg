import json
import sys
import os
# 添加项目根目录到路径
sys.path.append(os.path.join(os.path.dirname(__file__), '../../..'))
from utils.callapi import _qdd_api_inference
from config.apikey import QDD_APIKEY

with open("data/VersiBCB_Benchmark/vscc_datas.json","r") as f:
    vscc_datas = json.load(f)

def getIDcode(datas,id):
    for data in datas:
        if data["id"] == id:
            return data
    return None
def getErrorInfos(datas,id):
    for data in datas:
        if data["id"] == id:
            return data["error_infos"]
    return None
def buildQueryAnswer(codeinfo,error_infos):
    '''
    根据error_infos获取query(对于不确定的错误，需要生成query)和fix(对于确定的错误，需要生成fix)
    '''
    code = codeinfo["code"]
    dependency = codeinfo["dependency"]
    
    # 格式化error_infos为字符串
    error_infos_str = ""
    for error_info in error_infos:
        error_infos_str += f"Error ID: {error_info.get('error_id', 'N/A')}\n"
        error_infos_str += f"Tool: {error_info.get('tool', 'N/A')}\n"
        error_infos_str += f"Rule: {error_info.get('rule', 'N/A')}\n"
        error_infos_str += f"Error: {error_info.get('error_info', 'N/A')}\n\n"
    
    prompt = f"""
You are a helpful assistant that can help me generate a query and answer for a given code and error infos.
Dependency:
{dependency}

Here is the code:
{code}

Here is the error infos generated by static analysis for the code:
{error_infos_str}

Please generate code to fix the errors that you are very sure about, especially the errors that are unrelated to the dependency(like missed import, wrong syntax)
If you are not sure about the error, please generate a query to ask the user to provide more information.

error_ids are ids that fix or query is target at.
For the fix, just give out the code part that needed to be fixed(original code), and give the code part after fixing(fixed code).
* **`error_ids`**: An array of strings, listing the IDs of the errors addressed by this fix.
* **`original_code`**: A string containing the exact code snippet *before* your proposed fix.
* **`fixed_code`**: A string containing the corrected code snippet.

For the query, it should have two element: target_api_path and query_content. For target_api_path, it should be the api path that the error is related to. For query_content, it should be the query to ask the user to provide more information.
For example:
- target_api_path: "sklearn.feature_extraction.text.TfidfVectorizer"
- query_content: "What is the correct method to get feature names from TfidfVectorizer?"
## notes
1.Notably, in the error_info, before 'Error' is the original code part that the error occur, which may require adaption to make it work
2.original_code should be the same sentence as in the error_info.
The final output should be a json object with two elements: fixes and query.
For example:
{{
    "fixes": [{{"error_ids": ["error_0001", "error_0002"],"explanation": "The code is missing the import of matplotlib.pyplot, which result in the error 'No module named 'matplotlib.pyplot'. according to the dependency, we should first import matplotlib.pyplot", "original_code": "import seaborn as sns", "fixed_code": "import matplotlib.pyplot as plt\\nimport seaborn as sns"}}],
    "queries": [{{
        "error_ids": ["error_0003", "error_0004"],
        "target_api_path": "sklearn.feature_extraction.text.TfidfVectorizer",
        "query_content": "What is the correct method to get feature names from TfidfVectorizer in the current version?"
    }}]
}}

Notably, some errors may be just warnings that may be not correct, which originate from the static analysis tool. So, focus on the errors that are very likely to be correct. Distinguish the errors that are just warnings from the errors that are very likely to be correct.

Please respond with ONLY the JSON object, no additional text.
"""

    try:
        # 调用QDD API进行推理
        response = _qdd_api_inference(
            prompt=prompt,
            max_new_tokens=1024,
            temperature=1.0,
            top_p=0.95,
            api_key=QDD_APIKEY,
            model_name="@cf/meta/llama-3.1-8b-instruct",
            api_base_url=None
        )
        
        # 尝试解析JSON响应
        try:
            result = json.loads(response)
            return result
        except json.JSONDecodeError:
            # 如果直接解析失败，尝试提取JSON部分
            import re
            json_match = re.search(r'\{.*\}', response, re.DOTALL)
            if json_match:
                result = json.loads(json_match.group())
                return result
            else:
                print(f"无法解析API响应: {response}")
                return None
                
    except Exception as e:
        print(f"调用API时发生错误: {e}")
        return None

queryAnswer_prompt = """
given query and context, generate answer for the query.  the answer should give out the code part that needed to be fixed, and give the code part after fixing. 
code:
{code}
query:
{query}
context:
{context}
the final output should be a json object with two elements: fix and query.
for example:
{{
    "fix": "...",
    "query": {{
        "error_ids": ["...", "..."],
        "target_api_path": "...",
        "query_content": "..."
    }}
}}
"""

if __name__ == "__main__":
    # 使用带有error_id的新文件
    with open("data/temp/combined_errors_vscc_with_ids.json","r") as f:
        combined_errors_vscc = json.load(f)
    
    # 测试前几个数据项
    for i, data in enumerate(combined_errors_vscc[:3]):  # 只测试前3个
        id = data["id"]
        print(f"\n=== 处理ID: {id} ===")
        
        codeinfo = getIDcode(vscc_datas,id)
        if codeinfo is None:
            print(f"未找到ID {id} 对应的代码信息")
            continue
            
        error_infos = getErrorInfos(combined_errors_vscc,id)
        if error_infos is None:
            print(f"未找到ID {id} 对应的错误信息")
            continue
            
        QAinfo = buildQueryAnswer(codeinfo,error_infos)
        if QAinfo is not None:
            print("生成的查询和答案:")
            print(json.dumps(QAinfo, indent=2, ensure_ascii=False))
        else:
            print("生成查询和答案失败")
        
        print("-" * 50)