import json
import sys
import os
# 添加项目根目录到路径
sys.path.append(os.path.join(os.path.dirname(__file__), '../../..'))
from utils.callapi import _qdd_api_inference
from config.apikey import QDD_APIKEY

with open("data/VersiBCB_Benchmark/vscc_datas.json","r") as f:
    vscc_datas = json.load(f)

def getIDcode(datas,id):
    for data in datas:
        if data["id"] == id:
            return data
    return None

def getErrorInfos(datas,id):
    for data in datas:
        if data["id"] == id:
            return data["error_infos"]
    return None

def buildQueryOnly(codeinfo, error_infos):
    '''
    仅根据error_infos生成query，不生成fix
    '''
    code = codeinfo["code"]
    dependency = codeinfo["dependency"]
    
    # 格式化error_infos为字符串
    error_infos_str = ""
    for error_info in error_infos:
        error_infos_str += f"Error ID: {error_info.get('error_id', 'N/A')}\n"
        error_infos_str += f"Tool: {error_info.get('tool', 'N/A')}\n"
        error_infos_str += f"Rule: {error_info.get('rule', 'N/A')}\n"
        error_infos_str += f"Error: {error_info.get('error_info', 'N/A')}\n\n"
    
    prompt = f"""
You are a helpful assistant that generates queries for code errors that need more information or clarification.

Dependency:
{dependency}

Here is the code:
{code}

Here is the error infos generated by static analysis for the code:
{error_infos_str}

Your task is to analyze these errors and generate queries for situations where you need more information to provide a proper fix. You should generate queries for:
1. Errors related to external APIs or libraries where the correct usage might have changed
2. Errors where the intended behavior is unclear
3. Errors that might be false positives from static analysis tools
4. Complex errors that require domain knowledge

For each query, provide:
* **`error_ids`**: An array of strings, listing the IDs of the errors addressed by this query.
* **`target_api_path`**: The API path that the error is related to (e.g., "sklearn.feature_extraction.text.TfidfVectorizer.get_feature_names_out").
* **`query_content`**: A clear question asking for more information to resolve the error.
* **`explanation`**: Brief explanation of why this query is needed.

## Examples:
- target_api_path: "sklearn.feature_extraction.text.TfidfVectorizer"
- query_content: "What is the correct method to get feature names from TfidfVectorizer in the current version?"
- explanation: "The error indicates get_feature_names_out is unknown, but this might be a version issue."

## Notes:
1. Focus on errors that genuinely require external information or clarification
2. Avoid generating queries for simple syntax errors or obvious missing imports
3. Consider that some static analysis errors might be false positives
4. Group related errors into single queries when appropriate

The final output should be a JSON object with queries array:
{{
    "queries": [{{
        "error_ids": ["error_0001", "error_0002"],
        "target_api_path": "matplotlib.pyplot.subplots",
        "query_content": "What is the correct way to use plt.subplots with ax parameter in seaborn functions?",
        "explanation": "The error suggests ax parameter issue with seaborn.pairplot, need to clarify correct usage pattern."
    }}]
}}

Please respond with ONLY the JSON object, no additional text.
"""

    try:
        # 调用QDD API进行推理
        response = _qdd_api_inference(
            prompt=prompt,
            max_new_tokens=1024,
            temperature=0.7,
            top_p=0.95,
            api_key=QDD_APIKEY,
            model_name="@cf/meta/llama-3.1-8b-instruct",
            api_base_url=None
        )
        
        # 尝试解析JSON响应
        try:
            result = json.loads(response)
            return result
        except json.JSONDecodeError:
            # 如果直接解析失败，尝试提取JSON部分
            import re
            json_match = re.search(r'\{.*\}', response, re.DOTALL)
            if json_match:
                result = json.loads(json_match.group())
                return result
            else:
                print(f"无法解析API响应: {response}")
                return None
                
    except Exception as e:
        print(f"调用API时发生错误: {e}")
        return None

def save_queries_to_file(queries_data, output_file):
    """
    将生成的queries保存到文件
    """
    with open(output_file, 'w', encoding='utf-8') as f:
        json.dump(queries_data, f, indent=2, ensure_ascii=False)
    print(f"查询结果已保存到: {output_file}")

if __name__ == "__main__":
    # 使用带有error_id的新文件
    with open("data/temp/combined_errors_vscc_with_ids.json","r") as f:
        combined_errors_vscc = json.load(f)
    
    all_queries = []
    
    # 处理所有数据项
    for i, data in enumerate(combined_errors_vscc):
        id = data["id"]
        print(f"\n=== 处理ID: {id} ({i+1}/{len(combined_errors_vscc)}) ===")
        
        codeinfo = getIDcode(vscc_datas,id)
        if codeinfo is None:
            print(f"未找到ID {id} 对应的代码信息")
            continue
            
        error_infos = getErrorInfos(combined_errors_vscc,id)
        if error_infos is None:
            print(f"未找到ID {id} 对应的错误信息")
            continue
            
        query_info = buildQueryOnly(codeinfo, error_infos)
        if query_info is not None and "queries" in query_info:
            # 为每个query添加原始ID信息
            for query in query_info["queries"]:
                query["original_id"] = id
            all_queries.extend(query_info["queries"])
            print(f"生成了 {len(query_info['queries'])} 个查询")
        else:
            print("未生成查询")
    
    # 保存所有查询到文件
    output_data = {
        "total_queries": len(all_queries),
        "queries": all_queries
    }
    
    save_queries_to_file(output_data, "data/temp/generated_queries.json")
    print(f"\n=== 总结 ===")
    print(f"处理了 {len(combined_errors_vscc)} 个数据项")
    print(f"共生成了 {len(all_queries)} 个查询") 